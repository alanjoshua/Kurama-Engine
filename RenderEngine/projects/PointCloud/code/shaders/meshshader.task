/* Copyright (c) 2021, Sascha Willems
 *
 * SPDX-License-Identifier: MIT
 *
 */

#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require


struct ObjectData {
    mat4 model;
    float scale;
    vec3 _padding;
};

layout (set = 0, binding = 0) uniform CameraBuffer
{
    mat4 projview;
    mat4 view;
    mat4 proj;
    vec4 frustumPlanes[6];
} camera;

layout(std430, set = 0, binding = 1) readonly buffer ObjectBuffer {
    ObjectData objects[];
}objectBuffer;

// Binding 3: Indirect draw stats
layout (set = 0, binding = 3) buffer UBOOut
{
    int meshletDrawCount;
    int meshletRemovedCount;
    int meshletChildAddedCount;
} uboOut;

layout(set = 1, binding = 1) buffer UboIn {
    int meshletCount;
    int maxMeshletsToUpdate;
    int numDepthLevelsToRender;
    bool shouldRenderIndividualDepthLevels;
    float desiredDensity;
} uboIn;

layout(set = 1, binding = 2) readonly buffer MeshletsToBeDrawn {
    int indices[];
} meshletsToBeDrawn;

layout(set = 1, binding = 3) writeonly buffer MeshletsToBeRemoved {
    int array[];
} meshletsToBeRemoved;

layout(set = 1, binding = 4) writeonly buffer MeshletsChildrenAdded {
    int array[];
} meshletsChildrenAdded;

struct Meshlet {
    float vertexBegin;
    float vertexCount;
    float objectId;
    float density;
    vec4 bound; //vec3 = pos, w = bound sphere radius
    int treeDepth;
    ivec3 __; // padding
};

layout(std430, set = 1, binding = 0) readonly buffer MeshletBuffer {
    Meshlet meshlets[];
} meshletBuffer;

layout(local_size_x=32) in;

struct Task {
    uint baseID;
    uint subIDs[32];
};

taskPayloadSharedEXT Task task;

bool isWithinFrustum(vec4 pos, float radius) {
    // Check sphere against frustum planes
    for (int i = 0; i < 6; i++) {

        float dotProd = dot(pos, camera.frustumPlanes[i]);
        if (dotProd + radius < 0.0) {

            return false;
        }

    }
    return true;
}

void main() {

    if(gl_GlobalInvocationID.x >= uboIn.meshletCount) {
        return;
    }

    // Clear stats on first invocation
    if (gl_GlobalInvocationID.x == 0) {
        atomicExchange(uboOut.meshletDrawCount, 0);
        atomicExchange(uboOut.meshletRemovedCount, 0);
        atomicExchange(uboOut.meshletChildAddedCount, 0);
    }

    int meshletID = meshletsToBeDrawn.indices[int(gl_GlobalInvocationID.x)];
    Meshlet curMeshlet = meshletBuffer.meshlets[meshletID];

    ObjectData relatedModel = objectBuffer.objects[int(curMeshlet.objectId)];

    vec3 pos = curMeshlet.bound.xyz;
    float radius = curMeshlet.bound.w * relatedModel.scale;

    mat4 mvp = relatedModel.model;
    vec3 transfPos = (mvp * vec4(pos.xyz, 1.0)).xyz;

    bool doRender = false;
    if (uboIn.shouldRenderIndividualDepthLevels) {
        doRender = (curMeshlet.treeDepth == uboIn.numDepthLevelsToRender && isWithinFrustum(vec4(transfPos, 1.0), radius));
    }
    else {
        doRender = (curMeshlet.treeDepth <= uboIn.numDepthLevelsToRender && isWithinFrustum(vec4(transfPos, 1.0), radius));
    }

    uvec4 vote = subgroupBallot(doRender);
    uint numMeshlets = subgroupBallotBitCount(vote);

    if(doRender) {
        uint idxOffset = subgroupBallotExclusiveBitCount(vote);
        task.subIDs[idxOffset] = uint(meshletID);
        task.baseID = gl_WorkGroupID.x;

        atomicAdd(uboOut.meshletDrawCount, 1);

        float distToCamera = length(transfPos) * 0.01;
        float apparentDensity = radius * distToCamera; // Prob wrong

        if(apparentDensity < uboIn.desiredDensity) {
            int offset = atomicAdd(uboOut.meshletChildAddedCount, 1);
            meshletsChildrenAdded.array[offset] = meshletID;
        }
    }
    else {
//        if (uboOut.meshletRemovedCount < uboIn.maxMeshletsToUpdate) {
            meshletsToBeRemoved.array[atomicAdd(uboOut.meshletRemovedCount, 1)] = meshletID;
//        }
    }


    if(gl_LocalInvocationID.x == 0) {
        EmitMeshTasksEXT(numMeshlets, 1, 1);
    }


}