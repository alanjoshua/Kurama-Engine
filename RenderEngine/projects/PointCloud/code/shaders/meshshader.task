/* Copyright (c) 2021, Sascha Willems
 *
 * SPDX-License-Identifier: MIT
 *
 */

#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require


struct ObjectData {
    mat4 model;
    float scale;
    vec3 _padding;
};

layout (set = 0, binding = 0) uniform CameraBuffer
{
    mat4 projview;
    mat4 view;
    mat4 proj;
    vec4 frustumPlanes[6];
} camera;

layout(std430, set = 0, binding = 1) readonly buffer ObjectBuffer {
    ObjectData objects[];
}objectBuffer;

// Binding 3: Indirect draw stats
layout (set = 0, binding = 3) buffer UBOOut
{
    int meshletDrawCount;
    int meshletRemovedCount;
    int meshletChildAddedCount;
} uboOut;

layout(set = 1, binding = 3) buffer UboIn {
    int meshletCount;
    int maxMeshletsToUpdate;
    float desiredDensity;
} uboIn;

layout(set = 1, binding = 4) readonly buffer MeshletsToBeDrawn {
    int indices[];
} meshletsToBeDrawn;

layout(set = 1, binding = 5) writeonly buffer MeshletsToBeRemoved {
    int array[];
} meshletsToBeRemoved;

struct Meshlet {
// x = int primitiveCount;
// y = int vertexCount;
// z = int indexBegin;
// w = int vertexBegin;
    vec4 info;
    vec4 bound; //vec3 = pos, w = bound sphere radius
//    vec4 objectId; //yzw are padding
    float objectId;
    float density;
    vec2 _; //padding
};

layout(std140, set = 1, binding = 0) readonly buffer MeshletBuffer {
    Meshlet meshlets[];
} meshletBuffer;

layout(local_size_x=32) in;

struct Task {
    uint baseID;
    uint subIDs[32];
};

taskPayloadSharedEXT Task task;

bool isWithinFrustum(vec4 pos, float radius) {
    // Check sphere against frustum planes
    for (int i = 0; i < 6; i++) {

        float dotProd = dot(pos, camera.frustumPlanes[i]);
        if (dotProd + radius < 0.0) {

            return false;
        }

    }
    return true;
}

bool shouldRender(uint meshletID) {

    Meshlet curMeshlet = meshletBuffer.meshlets[meshletID];
    ObjectData relatedModel = objectBuffer.objects[int(curMeshlet.objectId)];

    vec3 pos = curMeshlet.bound.xyz;
    float radius = curMeshlet.bound.w * relatedModel.scale;

    mat4 mvp = relatedModel.model;
    vec4 transfPos = vec4((mvp * vec4(pos.xyz, 1.0)).xyz, 1.0);

    return isWithinFrustum(transfPos, radius);
}

void main() {

    int localId = int(gl_GlobalInvocationID.x);
    if(localId >= uboIn.meshletCount) {
        return;
    }

    // Clear stats on first invocation
    if (localId == 0) {
        atomicExchange(uboOut.meshletDrawCount, 0);
        atomicExchange(uboOut.meshletRemovedCount, 0);
    }

    int meshletID = meshletsToBeDrawn.indices[localId];
    bool doRender = shouldRender(meshletID);
    uvec4 vote = subgroupBallot(doRender);
    uint numMeshlets = subgroupBallotBitCount(vote);

    if(gl_LocalInvocationID.x == 0) {
        EmitMeshTasksEXT(numMeshlets, 1, 1);
    }

    if(doRender) {
        uint idxOffset = subgroupBallotExclusiveBitCount(vote);
        task.subIDs[idxOffset] = uint(meshletsToBeDrawn.indices[localId]);
        task.baseID = gl_WorkGroupID.x;

        atomicAdd(uboOut.meshletDrawCount, 1);
    }
    else {
        if (uboOut.meshletRemovedCount < uboIn.maxMeshletsToUpdate) {
            int offset = atomicAdd(uboOut.meshletRemovedCount, 1);
            meshletsToBeRemoved.array[offset] = meshletID;// This should be more complex to indicate what update should be done, such as removal, or should children be added
        }
    }


}