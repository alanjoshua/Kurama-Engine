/* Copyright (c) 2021, Sascha Willems
 *
 * SPDX-License-Identifier: MIT
 *
 */

#version 450
#extension GL_EXT_mesh_shader : require

layout (set = 0, binding = 0) uniform CameraBuffer
{
	mat4 projview;
	mat4 view;
	mat4 proj;
} camera;

struct Vertex {
    vec4 pos;
    vec4 color;
};

layout(std140, set = 0, binding = 1) readonly buffer VertexBuffer {
    Vertex vertices[];
}vertexBuffer;

struct ObjectData {
    mat4 model;
    float radius;
};

layout(std140, set = 0, binding = 2) readonly buffer ObjectBuffer {
    ObjectData objects[];
}objectBuffer;

struct Meshlet {
    // x = int primitiveCount;
    // y = int vertexCount;
    // z = int indexBegin;
    // w = int vertexBegin;
    vec4 info;
    vec4 bound; //vec3 = pos, w = bound sphere radius
}

layout(std140, set = 1, binding = 0) readonly buffer MeshletBuffer {
    Meshlet meshlets[];
} MeshletBuffer;

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 126) out;

layout(location = 0) out VertexOutput
{
	vec4 color;
} vertexOutput[];

const vec4[3] positions = {
	vec4( 0.0, -1.0, 0.0, 1.0),
	vec4(-1.0,  1.0, 0.0, 1.0),
	vec4( 1.0,  1.0, 0.0, 1.0)
};

const vec4[3] colors = {
	vec4(0.0, 1.0, 0.0, 1.0),
	vec4(0.0, 0.0, 1.0, 1.0),
	vec4(1.0, 0.0, 0.0, 1.0)
};

void main()
{
	uint iid = gl_LocalInvocationID.x;

	vec4 offset = vec4(0.0, 0.0, gl_GlobalInvocationID.x, 0.0);

	SetMeshOutputsEXT(3, 1);
	mat4 mvp = ubo.projection * ubo.view * ubo.model;
	gl_MeshVerticesEXT[0].gl_Position = mvp * (positions[0] + offset);
	gl_MeshVerticesEXT[1].gl_Position = mvp * (positions[1] + offset);
	gl_MeshVerticesEXT[2].gl_Position = mvp * (positions[2] + offset);
	vertexOutput[0].color = colors[0];
	vertexOutput[1].color = colors[1];
	vertexOutput[2].color = colors[2];
	gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationIndex] =  uvec3(0, 1, 2);
}