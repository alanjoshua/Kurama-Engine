#version 450
#extension GL_EXT_mesh_shader : require

layout (set = 0, binding = 0) uniform CameraBuffer
{
	mat4 projview;
	mat4 view;
	mat4 proj;
} camera;

struct ObjectData {
    mat4 model;
};

layout(std140, set = 0, binding = 1) readonly buffer ObjectBuffer {
    ObjectData objects[];
}objectBuffer;

struct Vertex {
    vec4 pos;
    vec4 color;
};

layout(std140, set = 0, binding = 2) readonly buffer VertexBuffer {
    Vertex vertices[];
}vertexBuffer;

struct Meshlet {
    // x = int primitiveCount;
    // y = int vertexCount;
    // z = int indexBegin;
    // w = int vertexBegin;
    vec4 info;
    vec4 bound; //vec3 = pos, w = bound sphere radius
    float objectId; //
    vec3 padding;
};

layout(std140, set = 1, binding = 0) readonly buffer MeshletBuffer {
    Meshlet meshlets[];
} meshletBuffer;

struct Index {
    uvec4 indicesInner;
};

layout(std140, set = 1, binding = 1) readonly buffer VertexIndexBuffer {
    Index indicesOuter[];
} vertexIndexBuffer;

layout(std140, set = 1, binding = 2) readonly buffer LocalIndexBuffer {
    Index indicesOuter[];
} localIndexBuffer;


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 124) out;

layout(location = 0) out VertexOutput
{
	vec4 color;
} OUT[];

struct Task {
  uint baseID;
  uint subIDs[32];
};

taskPayloadSharedEXT Task task;

void main()
{
	uint meshletID = (task.baseID * 32) + task.subIDs[gl_WorkGroupID.x];

    // 88 must be read from an UBO
    if(meshletID >= 88) {
        return;
    }

    Meshlet curMeshlet = meshletBuffer.meshlets[meshletID];
    ObjectData relatedModel = objectBuffer.objects[uint(curMeshlet.objectId)];

    uint primitiveCount = uint(curMeshlet.info.x);
    uint vertexCount = uint(curMeshlet.info.y);
    uint indexBegin = uint(curMeshlet.info.z);
    uint vertexBegin = uint(curMeshlet.info.w);
//
	SetMeshOutputsEXT(vertexCount, primitiveCount);
	mat4 mvp = camera.projview * relatedModel.model;

	for(int i = 0; i < vertexCount; i++) {
	    uint baseId = vertexBegin + i;
	    uint outerVertIndex = baseId / 4;
	    uint innerVertIndex = baseId % 4;
        uint finalVertId = vertexIndexBuffer.indicesOuter[outerVertIndex].indicesInner[innerVertIndex];

        gl_MeshVerticesEXT[i].gl_Position = mvp * vertexBuffer.vertices[finalVertId].pos;
        OUT[i].color = vertexBuffer.vertices[finalVertId].color;
	}
//
	for (uint i = 0; i < primitiveCount; i++) {

        uint baseId = indexBegin + (i*3);
	    uint outerVertIndex = baseId / 4;
	    uint innerVertIndex = baseId % 4;

        uvec3 finalInds = uvec3(
        localIndexBuffer.indicesOuter[outerVertIndex].indicesInner[innerVertIndex + 0],
        localIndexBuffer.indicesOuter[outerVertIndex].indicesInner[innerVertIndex + 1],
        localIndexBuffer.indicesOuter[outerVertIndex].indicesInner[innerVertIndex + 2]
        );

        gl_PrimitiveTriangleIndicesEXT[i] = finalInds;
	}

//    vec4 offset = vec4(task.subIDs[gl_WorkGroupID.x], 0, task.baseID, 0);
//
//	gl_MeshVerticesEXT[0].gl_Position = mvp * (vec4(0,0,1,1) + offset);
//	gl_MeshVerticesEXT[1].gl_Position = mvp * (vec4(1,0,1,1) + offset);
//	gl_MeshVerticesEXT[2].gl_Position = mvp * (vec4(1,1,1,1) + offset);
//
//    OUT[0].color = vec4(primitiveCount/255.0, 0, 0, 1);
//    OUT[1].color = vec4(0, 1, 0, 1);
//    OUT[2].color = vec4(0, 0, 1, 1);
////
//    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
//    SetMeshOutputsEXT(3, 1);


}